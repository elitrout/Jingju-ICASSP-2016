<!DOCTYPE html>
<meta charset="utf-8">
<html lang="en" ng-app="hamrSJ">
    <style>
        body { font: 12px Arial;}
        
        path { 
            stroke: PaleVioletRed;
            stroke-width: 2;
            fill: none;
        }
        
        .axis path,
        .axis line {
            fill: none;
            stroke: grey;
            stroke-width: 1;
            shape-rendering: crispEdges;
        }
    </style>

    <div id="area1" style="position:relative; top:0px; left:0px; margin:0 auto;"></div>
    <div id="control1" style="position:relative; top:35px; left:0px; margin:0 auto;">
        <button id="playButton_t" onclick="playButton_t_onclick()" style="text-align: middle;">Play</button>
    </div>
    <div id="wave1" style="position:relative; margin:0 left; top:10px; height:30px; border:1px solid lightgrey;"></div>
    <div id="area2" style="position:relative; top:20px; left:0px; margin:0 auto;"></div>
    <div id="control2" style="position:relative; top:55px; left:0px; margin:0 auto;">
        <button id="playButton_s" onclick="playButton_s_onclick()">Play</button>
    </div>
    <div id="wave2" style="position:relative; margin:0 left; top:30px; height:30px; border:1px solid lightgrey;"></div>
    <div ng-controller="RecordController as rec" id="control3" style="position:relative; top:55px; left:0px; margin:0 auto;">
    <button id="recordButton" ng-mousedown="rec.startRecording()" ng-mouseup="rec.stopRecording()" ng-class="{'btn-danger': rec.isRecording(), btn: true}">
    <b>Click and hold to record!</b>
    </button>
    <b><span id="recordingInfo" style="font-size:14px"> Ready to record.</span></b>
    </div>

    <head>
        <title>Demo</title>
        <script type="text/javascript" src="thirdparty/d3/d3.js" charset="utf-8"></script>
        <script type="text/javascript" src="thirdparty/wavesurfer.min.js"></script>
	<script type="text/javascript" src="thirdparty/angular.min.js"></script>
	<script type="text/javascript" src="thirdparty/recorder.js"></script>
        <script type="text/javascript" src="thirdparty/app.js"></script>
        <script src="thirdparty/jquery.min.js"></script>
    </head>

    <body ng-controller="SJController as sj">
        <script type="text/javascript">
            // Set the dimensions of the canvas / graph
            var margin = {top: 50, right: 20, bottom: 40, left: 50},
                width = 800 - margin.left - margin.right,
                height = 300 - margin.top - margin.bottom;

            // Set the ranges
            var x_t = d3.scale.linear().range([0, width]);
            var y_t = d3.scale.linear().range([height, 0]);
            var x_s = d3.scale.linear().range([0, width]);
            var y_s = d3.scale.linear().range([height, 0]);
            
            // Define the axes
            var xAxis_t = d3.svg.axis().scale(x_t)
                .orient("bottom").ticks(10);
            var yAxis_t = d3.svg.axis().scale(y_t)
                .orient("left").ticks(10);
            var xAxis_s = d3.svg.axis().scale(x_s)
                .orient("bottom").ticks(10);
            var yAxis_s = d3.svg.axis().scale(y_s)
                .orient("left").ticks(10);

        // Teacher plot
            
            // Adds the svg canvas
            var svg1 = d3.select("#area1")
                .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                .append("g")
                    .attr("transform", 
                          "translate(" + margin.left + "," + margin.top + ")");

            // Plot X axis label
            svg1.append("text")
               .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.bottom) + ")")
               .style("text-anchor", "middle")
               .text("Time");

            // Plot Y axis label
            svg1.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x",0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Pitch (MIDI)");

            // Plot title
            svg1.append("text")
               .attr("transform", "translate(" + (width / 2) + " ," + (0 - 10) + ")")
               .style("text-anchor", "middle")
               .style("font-size","20px")
               .style("font-weight","bold")
               .text("Teacher");

            // Define the line
            var pitchtrack1 = d3.svg.line()
                // .defined(function(d) { return !isNaN(d.pitch); })    // Don't plot silence (pitch value set to NaN)
                .defined(function(d) { return d.pitch>0 ? true:false; })    // Don't plot silence (negative pitch)
                .x(function(d) { return x_t(d.time); })
                .y(function(d) { return y_t(d.pitch); });

            // Plot pitch track
            d3.csv("data/teacher_regression_pitchtrack.csv", function(error, data) {
                data.forEach(function(d) {
                    d.time = +d.time;
                    d.pitch = +d.pitch;
                });
            
                // Scale the range of the data
                // x_t.domain([0, d3.max(data, function(d) { return d.time; })]).nice();
                // y_t.domain([d3.min(data, function(d) { if (d.pitch>0) {return d.pitch;}}), 2 + d3.max(data, function(d) { return d.pitch; })]).nice();
                x_t.domain([0, d3.max(data, function(d) { return d.time; })]);
                y_t.domain([d3.min(data, function(d) { if (d.pitch>0) {return d.pitch;}}), 2 + d3.max(data, function(d) { return d.pitch; })]);

                // Add the pitchtrack path.
                svg1.append("path")
                    .attr("class", "line")
                    .attr("d", pitchtrack1(data));
            
                // Add the X Axis
                svg1.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis_t);
            
                // Add the Y Axis
                svg1.append("g")
                    .attr("class", "y axis")
                    .call(yAxis_t);

		// Create focus line
		svg1.append("line")
		    .attr("id", "focus")
                    .attr("x1", x_t(0))
                    .attr("y1", height)
		    .attr("x2", x_t(0))
		    .attr("y2", 0)
                    // .attr("fill", "transparent")
		    .style("stroke", "black")
		    .style("stroke-dasharray", "1")
		    .style("display", "none");

		// Functions for mouse events
		var bisectTime = d3.bisector(function(d) { return d.time; }).left;

		function mousemove() {                            
                    // var x0 = x_t.invert(d3.mouse(svg1.select("#focusArea").node())[0]),
                    var x0 = x_t.invert(d3.mouse(this)[0]),
                        i = bisectTime(data, x0, 1),             
                        d0 = data[i - 1],              
                        d1 = data[i],                         
                        d = x0 - d0.time > d1.time - x0 ? d1 : d0;
    		    
                    svg1.select("#focus")                      
            		// .attr("x1", d3.mouse(svg1.select("#focusArea").node())[0])
            		.attr("x1", d3.mouse(this)[0])
            		.attr("y1", height)
            		.attr("x2", d3.mouse(this)[0])
            		.attr("y2", 0)
            		.attr("fill", "black");
		    
                    // Show pitch information
                    svg1.select("#info_note")
            		.attr("fill", "grey")
            		.text("Note: " + d.pitch);
                    svg1.select("#info_freq")
            		.attr("fill", "grey")
            		.text("Freq: " + d.pitch);
                    svg1.select("#info_time")
            		.attr("fill", "grey")
            		.text("Time: " + d.time)
		}
		
		// Navigate audio
		function mouseclick() {                            
                    var x0 = x_t.invert(d3.mouse(this)[0]);
                    i = bisectTime(data, x0, 1),              
                    d0 = data[i - 1],                         
                    d1 = data[i],                             
                    d = x0 - d0.time > d1.time - x0 ? d1 : d0;
		    
                    var progress = d.time / x_t.domain()[1];
		    
                    wavesurfer_t.seekTo(progress);
		}

		svg1.append("rect")
		    .attr("class", "overlay")
		    .attr("width", width)
		    .attr("height", height)
		    .attr("fill", "transparent")
		    .on("mouseover", function() { svg1.select("#focus").style("display", null); })
		    .on("mouseout", function() {
			                svg1.select("#focus").style("display", "none");
			                svg1.select("#info_note").attr("fill", "transparent");
			                svg1.select("#info_freq").attr("fill", "transparent");
			                svg1.select("#info_time").attr("fill", "transparent");
		                    })
		    .on("mousemove", mousemove)
		    .on("click", mouseclick);
            });

            // Read alignment dict
            var dictS2T_note;
            d3.tsv("data/amateur2pro.txt", function(error, data) {
                data.forEach(function(d) {
                    d.student = +d.student;
                    d.teacher = +d.teacher;
                });

		dictS2T_note = data;
	    });

            var dictT2S_note;
            d3.tsv("data/pro2amateur.txt", function(error, data) {
                data.forEach(function(d) {
                    d.student = +d.student;
                    d.teacher = +d.teacher;
                });

		dictT2S_note = data;
	    });

            // Plot MIDI notes

            svg1.append("text")
                .attr("id", "info_note")
                .attr("transform", "translate(" + width + " ," + 10 + ")")
                .attr("fill", "transparent")
                .style("text-anchor", "end")
            svg1.append("text")
                .attr("id", "info_freq")
                .attr("transform", "translate(" + width + " ," + 25 + ")")
                .attr("fill", "transparent")
                .style("text-anchor", "end")
            svg1.append("text")
                .attr("id", "info_time")
                .attr("transform", "translate(" + width + " ," + 40 + ")")
                .attr("fill", "transparent")
                .style("text-anchor", "end")

            var MIDInote_t;

            d3.tsv("data/pitchtracknotetranscriptionsegmentation/weiguojia_section_pro_monoNoteOut_midi.txt", function(error, data) {
                data.forEach(function(d) {
                    d.startTime = +d.startTime;
                    d.pitch = +d.pitch;
                    d.duration = +d.duration;
                });
		
		MIDInote_t = data;
		
	    	var MIDInotes = svg1.selectAll("rect")
                                   .data(data)
                                   .enter()
                                   .append("rect");

		var MIDInoteOffset = 4;    // The vertical center of the note rect is aligned to the pitch
	    	MIDInotes.attr("x", function(d) {return x_t(d.startTime);})
	    	         .attr("y", function(d) {return y_t(d.pitch) - MIDInoteOffset;})
	    	         .attr("width", function(d) {return x_t(d.duration);})
	    	         .attr("height", 8)
		         .attr("fill", "DarkCyan")
		         .attr("opacity", 0.7)
		         .attr("id", function(d, i){var noteid = 't'+i; return noteid; })    // Note ID for alignment visualization
		         .on("mouseover", function(d, i) {
			                      // Hide focus line
			                      svg1.select("#focus").style("display", "none");
			                      // Highlight current note
			                      d3.select(this).attr("fill", "Purple");
			                      // Draw note boundary
			                      var note_t = d.pitch
			                      var noteStart_t = Number(d3.select(this).attr("x"));
			                      var noteStartTime_t = MIDInote_t[i].startTime;
			                      var noteDuration_t = Number(d3.select(this).attr("width"));
			                      var noteDurationTime_t = MIDInote_t[i].duration;
					      var noteEnd_t = noteStart_t + noteDuration_t;
					      var noteEndTime_t = noteStartTime_t + noteDurationTime_t;

			                      svg1.append("line")
				                  .attr("id", "noteBoundaryL")
				                  .attr("x1", noteStart_t)
				                  .attr("y1", height)
				                  .attr("x2", noteStart_t)
				                  .attr("y2", 0)
				                  .style("stroke", "grey")
				                  .style("stroke-dasharray", "3");
			                      svg1.append("line")
				                  .attr("id", "noteBoundaryR")
				                  .attr("x1", noteEnd_t) 
				                  .attr("y1", height)
				                  .attr("x2", noteEnd_t)
				                  .attr("y2", 0)
				                  .style("stroke", "grey")
				                  .style("stroke-dasharray", "3");

			                      // Print note information
			                      svg1.select("#info_note")
                                                  .attr("fill", "grey")
				                  .text("Note: " + note_t);
			                      svg1.select("#info_freq")
			                          .attr("fill", "grey")
				                  .text("Freq: " + note_t);
			                      svg1.select("#info_time")
			                          .attr("fill", "grey")
				                  .text("Time: " + noteStartTime_t.toFixed(2) + ' - ' + (Number(noteStartTime_t.toFixed(2)) + Number(noteDurationTime_t.toFixed(2))).toFixed(2) + 's (' + noteDurationTime_t.toFixed(2) + 's)');

			                      // Act on the aligned note from student
			                      var pair_s = dictT2S_note[i].student;

			                      if (!isNaN(pair_s)) {

						  d3.select("#s"+pair_s).attr("fill", "Purple");
						  var note_s = MIDInote_s[pair_s].pitch;
						  var noteStart_s = Number(d3.select("#s"+pair_s).attr("x"));
						  var noteStartTime_s = MIDInote_s[pair_s].startTime;
						  var noteDuration_s = Number(d3.select("#s"+pair_s).attr("width"));
						  var noteDurationTime_s = MIDInote_s[pair_s].duration;
						  var noteEnd_s = noteStart_s + noteDuration_s;
						  var noteEndTime_s = noteStartTime_s + noteDurationTime_s;
						  svg2.append("line")
				                      .attr("id", "noteBoundaryL")
				                      .attr("x1", noteStart_s)
				                      .attr("y1", height)
				                      .attr("x2", noteStart_s)
				                      .attr("y2", 0)
				                      .style("stroke", "grey")
				                      .style("stroke-dasharray", "3");
						  svg2.append("line")
				                      .attr("id", "noteBoundaryR")
				                      .attr("x1", noteEnd_s) 
				                      .attr("y1", height)
				                      .attr("x2", noteEnd_s)
				                      .attr("y2", 0)
				                      .style("stroke", "grey")
				                      .style("stroke-dasharray", "3");

						  svg2.select("#info_note")
			                              .attr("fill", "grey")
				                      .text("Note: " + note_s);
						  svg2.select("#info_freq")
			                              .attr("fill", "grey")
				                      .text("Freq: " + note_s);
						  svg2.select("#info_time")
			                              .attr("fill", "grey")
				                      .text("Time: " + noteStartTime_s.toFixed(2) + ' - ' + (Number(noteStartTime_s.toFixed(2)) + Number(noteDurationTime_s.toFixed(2))).toFixed(2) + 's (' + noteDurationTime_s.toFixed(2) + 's)');
					      }
			                  })
		         .on("mouseout", function(d, i) {
			                     // Show focus line
			                     svg1.select("#focus").style("display", null);
			                     // d3.select("#t"+i).attr("fill", "DarkCyan");
			                     // d3.selectAll("rect").attr("fill", "DarkCyan");
			                     d3.select(this).attr("fill", "DarkCyan");
			                     // svg1.selectAll('line').remove();
			                     svg1.select('#noteBoundaryL').remove();
			                     svg1.select('#noteBoundaryR').remove();
			                     // svg1.select("#info_note").remove();
			                     // svg1.select("#info_freq").remove();
			                     // svg1.select("#info_time").remove();
			                     svg1.select("#info_note").attr("fill", "transparent");
			                     svg1.select("#info_freq").attr("fill", "transparent");
			                     svg1.select("#info_time").attr("fill", "transparent");

			                     // Act on the aligned note from student
			                     var pair_s = dictT2S_note[i].student;

			                     if (!isNaN(pair_s)) {
						 // d3.select("#s"+i).attr("fill", "DarkCyan");
						 svg2.select("#s"+pair_s).attr("fill", "DarkCyan");
						 svg2.select('#noteBoundaryL').remove();
						 svg2.select('#noteBoundaryR').remove();
						 // svg2.select("#info_note").remove();
						 // svg2.select("#info_freq").remove();
						 // svg2.select("#info_time").remove();
						 svg2.select("#info_note").attr("fill", "transparent");
						 svg2.select("#info_freq").attr("fill", "transparent");
						 svg2.select("#info_time").attr("fill", "transparent");
					     }
			                 })
		         // Play note on click
                         .on("click", function (d, i) {
			                  var noteStartTime = d.startTime;
			                  var noteDurationTime = d.duration;
			                  var noteEndTime = noteStartTime + noteDurationTime;
			                  wavesurfer_t.play(noteStartTime, noteEndTime);
			 });
            });

            // Add audio player
            wave1.style.width = width + "px";
            wave1.style.left = margin.left + "px";
            playButton_t.style.width = "45px";
            // play_t.style.float = "left";
            // play_t.style.margin-left = "5px";

            var wavesurfer_t = WaveSurfer.create({
                container: '#wave1',
                waveColor: 'grey',
                progressColor: 'DarkTurquoise',
		fillParent: true,
		height: 30
		// minPxPerSec: 10
            });

            wavesurfer_t.load('data/weiguojia_section_pro.wav');

            // Plot moving playback cursor on pitchtrack
            svg1.append("line")
		.attr("id", "playbackPointer_t")
                .attr("x1", x_t(0))
                .attr("y1", height)
		.attr("x2", x_t(0))
		.attr("y2", 0)
		.style("stroke", "black");

            wavesurfer_t.on('audioprocess', function () {
                currentTime = wavesurfer_t.getCurrentTime();
		d3.select("#playbackPointer_t")
		    .attr("x1", x_t(currentTime))
		    .attr("y1", height)
		    .attr("x2", x_t(currentTime))
		    .attr("y2", 0)
		    .style("stroke", "black");
            });

            wavesurfer_t.on('finish', function () {
		d3.select("#playbackPointer_t")
		    .attr("x1", x_t(0))
		    .attr("y1", height)
		    .attr("x2", x_t(0))
		    .attr("y2", 0)
		    .style("stroke", "black");

		document.getElementById("playButton_t").innerHTML = "Play";
            });

            wavesurfer_t.on('seek', function () {
                currentTime = wavesurfer_t.getCurrentTime();
		d3.select("#playbackPointer_t")
		    .attr("x1", x_t(currentTime))
		    .attr("y1", height)
		    .attr("x2", x_t(currentTime))
		    .attr("y2", 0)
		    .style("stroke", "black");
            });

            function playButton_t_onclick () {
		wavesurfer_t.playPause();
		if (wavesurfer_t.isPlaying()) {
		    document.getElementById("playButton_t").innerHTML = "Pause";
		} else {
		    document.getElementById("playButton_t").innerHTML = "Play";
		}
	    }


        // Student plot
            
            // Adds the svg canvas
            var svg2 = d3.select("#area2")
                .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                .append("g")
                    .attr("transform", 
                          "translate(" + margin.left + "," + margin.top + ")");

            // Plot X axis label
            svg2.append("text")
               .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.bottom) + ")")
               .style("text-anchor", "middle")
               .text("Time");

            // Plot Y axis label
            svg2.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x",0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Pitch (MIDI)");

            // Plot title
            svg2.append("text")
               .attr("transform", "translate(" + (width / 2) + " ," + (0 - 10) + ")")
               .style("text-anchor", "middle")
               .style("font-size","20px")
               .style("font-weight","bold")
               .text("Student");

            // Define the line
            var pitchtrack2 = d3.svg.line()
                // .defined(function(d) { return !isNaN(d.pitch); })    // Don't plot silence (pitch value set to NaN)
                .defined(function(d) { return d.pitch>0 ? true:false; })    // Don't plot silence (negative pitch)
                .x(function(d) { return x_s(d.time); })
                .y(function(d) { return y_s(d.pitch); });



            // Plot pitch track
            d3.csv("data/student_regression_pitchtrack.csv", function(error, data) {
                data.forEach(function(d) {
                    d.time = +d.time;
                    d.pitch = +d.pitch;
                });
            
                // Scale the range of the data
                x_s.domain([0, d3.max(data, function(d) { return d.time; })]);
		y_s.domain([d3.min(data, function(d) { if (d.pitch>0) {return d.pitch;}}), 2 + d3.max(data, function(d) { return d.pitch; })]);

                // Add the pitchtrack path.
                svg2.append("path")
		    .attr("id", "path_s")
                    .attr("class", "line")
                    .attr("d", pitchtrack2(data))
		    .style("pointer-events", "none");    // Prevent mouseover failing on overlapping part
            
                // Add the X Axis
                svg2.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis_s);
            
                // Add the Y Axis
                svg2.append("g")
                    .attr("class", "y axis")
                    .call(yAxis_s);

		// Create focus line
		svg2.append("line")
		    .attr("id", "focus")
                    .attr("x1", x_s(0))
                    .attr("y1", height)
		    .attr("x2", x_s(0))
		    .attr("y2", 0)
                    // .attr("fill", "transparent")
		    .style("stroke", "black")
		    .style("stroke-dasharray", "1")
		    .style("display", "none");

		var bisectTime = d3.bisector(function(d) { return d.time; }).left;

		function mousemove() {                            
		    var x0 = x_s.invert(d3.mouse(this)[0]),         
		    i = bisectTime(data, x0, 1),              
		    d0 = data[i - 1],                         
		    d1 = data[i],                             
		    d = x0 - d0.time > d1.time - x0 ? d1 : d0;

		    svg2.select("#focus")                      
			.attr("x1", d3.mouse(this)[0])
			.attr("y1", height)
			.attr("x2", d3.mouse(this)[0])
			.attr("y2", 0)
			.attr("fill", "black");

		    // Show pitch information
		    svg2.select("#info_note")
			.attr("fill", "grey")
			.text("Note: " + d.pitch);
		    svg2.select("#info_freq")
			.attr("fill", "grey")
			.text("Freq: " + d.pitch);
		    svg2.select("#info_time")
			.attr("fill", "grey")
		        .text("Time: " + d.time)
		}

		// Navigate audio
		function mouseclick() {                            
		    var x0 = x_s.invert(d3.mouse(this)[0]);
		    // var x0 = x_s.invert(d3.mouse(svg2.select("#focusArea").node())[0]);
		    i = bisectTime(data, x0, 1),              
		    d0 = data[i - 1],                         
		    d1 = data[i],                             
		    d = x0 - d0.time > d1.time - x0 ? d1 : d0;

		    var progress = d.time / x_s.domain()[1];

		    wavesurfer_s.seekTo(progress);
		}

		// Focus detection area
		svg2.append("rect")
		    .attr("id", "focusArea")
		    .attr("class", "overlay")
		    .attr("width", width)
		    .attr("height", height)
		    .attr("fill", "transparent")
		    .on("mouseover", function() { svg2.select("#focus").style("display", null); })
		    .on("mouseout", function() {
			                svg2.select("#focus").style("display", "none");
			                svg2.select("#info_note").attr("fill", "transparent");
			                svg2.select("#info_freq").attr("fill", "transparent");
			                svg2.select("#info_time").attr("fill", "transparent");
		                    })
		    .on("mousemove", mousemove)
		    .on("click", mouseclick);
            });

            // Plot MIDI notes

            svg2.append("text")
                .attr("id", "info_note")
                .attr("transform", "translate(" + width + " ," + 10 + ")")
                .attr("fill", "transparent")
                .style("text-anchor", "end")
            svg2.append("text")
                .attr("id", "info_freq")
                .attr("transform", "translate(" + width + " ," + 25 + ")")
                .attr("fill", "transparent")
                .style("text-anchor", "end")
            svg2.append("text")
                .attr("id", "info_time")
                .attr("transform", "translate(" + width + " ," + 40 + ")")
                .attr("fill", "transparent")
                .style("text-anchor", "end")

            var MIDInote_s;

            d3.tsv("data/pitchtracknotetranscriptionsegmentation/weiguojia_section_amateur_monoNoteOut_midi.txt", function(error, data) {
                data.forEach(function(d) {
                    d.startTime = +d.startTime;
                    d.pitch = +d.pitch;
	    	    d.duration = +d.duration;
                });

		MIDInote_s = data;

	    	var MIDInotes = svg2.selectAll("rect")
                                   .data(data)
                                   .enter()
                                   .append("rect");

	    	MIDInotes.attr("x", function(d) {return x_s(d.startTime);})
	    	         .attr("y", function(d) {return y_s(d.pitch) - 4;})
    	                 .attr("width", function(d) {return x_s(d.duration);})
   	                 .attr("height", 8)
        	         .attr("fill", "DarkCyan")
		         .attr("opacity", 0.7)
		         .attr("id", function(d, i){var noteid = 's'+i; return noteid; })    // Note ID for alignment visualization
		         .on("mouseover", function(d, i) {
			                      // Hide focus line
			                      svg1.select("#focus").style("display", "none");
			                      // Highlight current note
			                      d3.select(this).attr("fill", "Purple");
			                      // Draw note boundary
			                      var note_s = d.pitch
			                      var noteStart_s = Number(d3.select(this).attr("x"));
			                      var noteStartTime_s = MIDInote_s[i].startTime;
			                      var noteDuration_s = Number(d3.select(this).attr("width"));
			                      var noteDurationTime_s = MIDInote_s[i].duration;
					      var noteEnd_s = noteStart_s + noteDuration_s;
					      var noteEndTime_s = noteStartTime_s + noteDurationTime_s;

			                      svg2.append("line")
				                  // .attr("x1", x(d.startTime))
				                  .attr("id", "noteBoundaryL")
				                  .attr("x1", noteStart_s)
				                  .attr("y1", height)
				                  .attr("x2", noteStart_s)
				                  .attr("y2", 0)
				                  .style("stroke", "grey")
				                  .style("stroke-dasharray", "3");
			                      svg2.append("line")
				                  .attr("id", "noteBoundaryR")
				                  .attr("x1", noteEnd_s) 
				                  .attr("y1", height)
				                  .attr("x2", noteEnd_s)
				                  .attr("y2", 0)
				                  .style("stroke", "grey")
				                  .style("stroke-dasharray", "3");

			                      // Print note information
			                      svg2.select("#info_note")
                                                  .attr("fill", "grey")
				                  .text("Note: " + note_s);
			                      svg2.select("#info_freq")
			                          .attr("fill", "grey")
				                  .text("Freq: " + note_s);
			                      svg2.select("#info_time")
			                          .attr("fill", "grey")
				                  .text("Time: " + noteStartTime_s.toFixed(2) + ' - ' + (Number(noteStartTime_s.toFixed(2)) + Number(noteDurationTime_s.toFixed(2))).toFixed(2) + 's (' + noteDurationTime_s.toFixed(2) + 's)');


			                      // Act on the aligned note from teacher
			                      var pair_t = dictS2T_note[i].teacher;

			                      if (!isNaN(pair_t)) {

						  d3.select("#t"+pair_t).attr("fill", "Purple");
						  var note_t = MIDInote_t[pair_t].pitch;
						  var noteStart_t = Number(d3.select("#t"+pair_t).attr("x"));
						  var noteStartTime_t = MIDInote_t[pair_t].startTime;
						  var noteDuration_t = Number(d3.select("#t"+pair_t).attr("width"));
						  var noteDurationTime_t = MIDInote_t[pair_t].duration;
						  var noteEnd_t = noteStart_t + noteDuration_t;
						  var noteEndTime_t = noteStartTime_t + noteDurationTime_t;
						  svg1.append("line")
				                      .attr("id", "noteBoundaryL")
				                      .attr("x1", noteStart_t)
				                      .attr("y1", height)
				                      .attr("x2", noteStart_t)
				                      .attr("y2", 0)
				                      .style("stroke", "grey")
				                      .style("stroke-dasharray", "3");
						  svg1.append("line")
				                      .attr("id", "noteBoundaryR")
				                      .attr("x1", noteEnd_t) 
				                      .attr("y1", height)
				                      .attr("x2", noteEnd_t)
				                      .attr("y2", 0)
				                      .style("stroke", "grey")
				                      .style("stroke-dasharray", "3");

						  svg1.select("#info_note")
			                              .attr("fill", "grey")
				                      .text("Note: " + note_t);
						  svg1.select("#info_freq")
			                              .attr("fill", "grey")
				                      .text("Freq: " + note_t);
						  svg1.select("#info_time")
			                              .attr("fill", "grey")
				                      .text("Time: " + noteStartTime_t.toFixed(2) + ' - ' + (Number(noteStartTime_t.toFixed(2)) + Number(noteDurationTime_t.toFixed(2))).toFixed(2) + 's (' + noteDurationTime_t.toFixed(2) + 's)');
					      }
			                  })
		         .on("mouseout", function(d, i) {
			                     // Show focus line
			                     svg2.select("#focus").style("display", null);

			                     d3.select(this).attr("fill", "DarkCyan");
			                     svg2.select('#noteBoundaryL').remove();
			                     svg2.select('#noteBoundaryR').remove();
			                     svg2.select("#info_note").attr("fill", "transparent");
			                     svg2.select("#info_freq").attr("fill", "transparent");
			                     svg2.select("#info_time").attr("fill", "transparent");

			                     // Act on the aligned note from student
			                     var pair_t = dictS2T_note[i].teacher;

			                     if (!isNaN(pair_t)) {
						 svg1.select("#t"+pair_t).attr("fill", "DarkCyan");
						 svg1.select('#noteBoundaryL').remove();
						 svg1.select('#noteBoundaryR').remove();
						 svg1.select("#info_note").attr("fill", "transparent");
						 svg1.select("#info_freq").attr("fill", "transparent");
						 svg1.select("#info_time").attr("fill", "transparent");					     }
			                 })
		         // Play note on click
                         .on("click", function (d, i) {
			                  var noteStartTime = d.startTime;
			                  var noteDurationTime = d.duration;
			                  var noteEndTime = noteStartTime + noteDurationTime;
			                  wavesurfer_s.play(noteStartTime, noteEndTime);
			 });
            });

            // Add audio player
            wave2.style.width = width + "px";
            wave2.style.left = margin.left + "px";
            playButton_s.style.width = "45px";

            var wavesurfer_s = WaveSurfer.create({
                container: '#wave2',
                waveColor: 'grey',
                progressColor: 'DarkTurquoise',
		fillParent: true,
		height: 30
		// minPxPerSec: 10
            });

            wavesurfer_s.load('data/weiguojia_section_amateur.wav');

            // Plot moving playback cursor on pitchtrack
            svg2.append("line")
		.attr("id", "playbackPointer_s")
                .attr("x1", x_t(0))
                .attr("y1", height)
		.attr("x2", x_t(0))
		.attr("y2", 0)
		.style("stroke", "black");

            wavesurfer_s.on('audioprocess', function () {
                currentTime = wavesurfer_s.getCurrentTime();
		d3.select("#playbackPointer_s")
		    .attr("x1", x_s(currentTime))
		    .attr("y1", height)
		    .attr("x2", x_s(currentTime))
		    .attr("y2", 0)
		    .style("stroke", "black");
            });

            wavesurfer_s.on('finish', function () {
		d3.select("#playbackPointer_s")
		    .attr("x1", x_s(0))
		    .attr("y1", height)
		    .attr("x2", x_s(0))
		    .attr("y2", 0)
		    .style("stroke", "black");

		document.getElementById("playButton_t").innerHTML = "Play";
            });

            wavesurfer_s.on('seek', function () {
                currentTime = wavesurfer_s.getCurrentTime();
		d3.select("#playbackPointer_s")
		    .attr("x1", x_s(currentTime))
		    .attr("y1", height)
		    .attr("x2", x_s(currentTime))
		    .attr("y2", 0)
		    .style("stroke", "black");
            });

            function playButton_s_onclick () {
		wavesurfer_s.playPause();
		if (wavesurfer_s.isPlaying()) {
		    document.getElementById("playButton_s").innerHTML = "Pause";
		} else {
		    document.getElementById("playButton_s").innerHTML = "Play";
		}
	    }

            // Update visualization when finish recording
            function updateData () {
		// Update student pitch track
		d3.csv("data/teacher_regression_pitchtrack.csv", function(error, data) {
                    data.forEach(function(d) {
			d.time = +d.time;
			d.pitch = +d.pitch;
                    });
		    
                    // Scale the range of the data
                    x_s.domain([0, d3.max(data, function(d) { return d.time; })]);
		    y_s.domain([d3.min(data, function(d) { if (d.pitch>0) {return d.pitch;}}), 2 + d3.max(data, function(d) { return d.pitch; })]);

                    // Update X Axis
                    svg2.select(".x.axis")
			.call(xAxis_s);
		    
                    // Update Y Axis
                    svg2.select(".y.axis")
			.call(yAxis_s);

		    // Update pitch
		    svg2.select("#path_s").attr("d", pitchtrack2(data));

		    var bisectTime = d3.bisector(function(d) { return d.time; }).left;

		    function mousemove() {                            
			var x0 = x_s.invert(d3.mouse(svg2.select("#focusArea").node())[0]),         
			i = bisectTime(data, x0, 1),              
			d0 = data[i - 1],                         
			d1 = data[i],                             
			d = x0 - d0.time > d1.time - x0 ? d1 : d0;

			svg2.select("#focus")                      
			    .attr("x1", d3.mouse(svg2.select("#focusArea").node())[0])
			    .attr("y1", height)
			    .attr("x2", d3.mouse(svg2.select("#focusArea").node())[0])
			    .attr("y2", 0)
			    .attr("fill", "black");

			// Show pitch information
			svg2.select("#info_note")
			    .attr("fill", "grey")
			    .text("Note: " + d.pitch);
			svg2.select("#info_freq")
			    .attr("fill", "grey")
			    .text("Freq: " + d.pitch);
			svg2.select("#info_time")
			    .attr("fill", "grey")
		            .text("Time: " + d.time)
		    }

		    // Navigate audio
		    function mouseclick() {                            
			var x0 = x_s.invert(d3.mouse(svg2.select("#focusArea").node())[0]);
			// var x0 = x_s.invert(d3.mouse(svg2.select("#focusArea").node())[0]);
			i = bisectTime(data, x0, 1),              
			d0 = data[i - 1],                         
			d1 = data[i],                             
			d = x0 - d0.time > d1.time - x0 ? d1 : d0;

			var progress = d.time / x_s.domain()[1];

			wavesurfer_s.seekTo(progress);
		    }

		    svg2.select("#focusArea").on("mousemove", mousemove)
                                             .on("click", mouseclick);

		    // Update audio
		    wavesurfer_s.load('data/weiguojia_section_pro.wav');

		    wavesurfer_s.unAll();

		    wavesurfer_s.on('audioprocess', function () {
			currentTime = wavesurfer_s.getCurrentTime();
			d3.select("#playbackPointer_s")
			    .attr("x1", x_s(currentTime))
			    .attr("y1", height)
			    .attr("x2", x_s(currentTime))
			    .attr("y2", 0)
			    .style("stroke", "black");
		    });

		    wavesurfer_s.on('finish', function () {
			d3.select("#playbackPointer_s")
			    .attr("x1", x_s(0))
			    .attr("y1", height)
			    .attr("x2", x_s(0))
			    .attr("y2", 0)
			    .style("stroke", "black");

			document.getElementById("playButton_t").innerHTML = "Play";
		    });

		    wavesurfer_s.on('seek', function () {
			currentTime = wavesurfer_s.getCurrentTime();
			d3.select("#playbackPointer_s")
			    .attr("x1", x_s(currentTime))
			    .attr("y1", height)
			    .attr("x2", x_s(currentTime))
			    .attr("y2", 0)
			    .style("stroke", "black");
		    });

		})
	    }

        </script>
    </body>
</html>     
